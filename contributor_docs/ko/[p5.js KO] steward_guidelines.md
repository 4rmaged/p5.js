# Steward Guidelines

Whether you have just joined us as a steward, are a seasoned maintainer of p5.js, or are somewhere in between, this guide contains information as well as tips and tricks that will help you effectively contribute to p5.js. Most of what is written here are guidelines unless otherwise stated, which means you can adapt the practices shown here to suit your workflow.


## Table of Contents

- [Issues](steward_guidelines.md#issues)
  - [Bug report](steward_guidelines.md#bug-report)
  - [Feature request](steward_guidelines.md#feature-request)
  - [Feature enhancement](steward_guidelines.md#feature-enhancement)
  - [Discussion](steward_guidelines.md#discussion)
- [Pull Requests](steward_guidelines.md#pull-requests)
  - [Simple fix](steward_guidelines.md#simple-fix)
  - [Bug fix](steward_guidelines.md#bug-fix)
  - [New feature/feature enhancement](steward_guidelines.md#new-feature-feature-enhancement)
  - [Dependabot](steward_guidelines.md#dependabot)
- [Build Process](steward_guidelines.md#build-process)
  - [Main build task](steward_guidelines.md#main-build-task)
  - [Miscellaneous tasks](steward_guidelines.md#miscellaneous-tasks)
- [Release Process](steward_guidelines.md#release-process)
- [Tips & Tricks](steward_guidelines.md#tips--tricks)
  - [Reply templates](steward_guidelines.md#reply-templates)
  - [GitHub CLI](steward_guidelines.md#github-cli)
  - [Managing notifications](steward_guidelines.md#managing-notifications)

---


## Issues

We encourage most source code contributions to start with an issue, and as such, issues are the place where most of the discussions will take place. The steps to take when reviewing an issue will depend on what kind of issue it is. The repo uses [GitHub issue templates](https://github.com/processing/p5.js/blob/main/.github/ISSUE_TEMPLATE) in order to better organize different kinds of issues and encourage issue authors to provide all relevant information about their problems. The first step in reviewing the issue will often be looking through the filled-out template and determining if you need additional information (e.g., because some fields weren't filled in or the incorrect template was used).


### Bug report

Bug report issues should use the "Found a bug" issue template. The following workflow is typical for addressing bug reports:

1. Replicate the bug
   - The goal of the template is to provide enough information for a reviewer to attempt to replicate the bug in question.
   - If the reported bug is not relevant to the repo it is opened in (p5.js, p5.js-website, or otherwise):
     - Transfer the issue to the relevant repo if you have access to it.
     - Otherwise, leave a comment about where the bug report should be filed (with a direct link provided) and close the issue.
   - The first step in reviewing a bug report is to see if enough information is provided for a bug replication, and if so, attempt to replicate the bug as described.
2. If the bug can be replicated:
   - Some discussion may be required to determine the best way to fix a particular bug. Sometimes, it may be straightforward; sometimes, it may be tricky. Please refer to [p5.js' design principles](design_principles.md) when making this decision on a case-by-case basis.
   - If the issue author indicated in the issue they are willing to contribute a fix:
     - Approve the issue for fixing by the issue author by leaving a comment and assigning them to the issue. Use the cog button on the right side next to "Assignee".
   - If the issue author does not wish to contribute a fix:
     - Leave a comment recognizing the bug is replicable.
     - Attempt to fix yourself or add the `help wanted` label to signal an issue needing a fix.
3. If the bug cannot be replicated:
   - Ask for additional info if not already provided in the template (p5.js version, browser version, OS version, etc.).
   - If your testing environment differs from what is reported in the issue (e.g., a different browser or OS):
     - Leave a comment saying you are not able to replicate in your specific environment.
     - Add a `help wanted` label to the issue and ask for someone else with the setup specified in the issue to try to replicate the bug.
   - Sometimes, bugs only occur when using the web editor and not when testing locally. In this case, the issue should be redirected to the [web editor repo](https://github.com/processing/p5.js-web-editor).
   - If replication is possible later, go back to step 2.
4. If the bug stems from the code the user provided in the bug report and not p5.js' behavior:
   - Determine if p5.js' documentation, code implementation, or friendly error system can be improved to prevent the same mistake from being made.
   - Kindly redirect any further questions to the [forum](https://discourse.processing.org/) or [Discord](https://discord.com/invite/SHQ8dH25r9) and close the issue if no further changes are to be made to p5.js.


### Feature request

Feature request issues should use the "New Feature Request" issue template. The following workflow is typical for addressing feature requests:

1. As part of p5.js' commitment to increase access, a feature request must make a case for how it increases access of p5.js to communities that are historically marginalized in the field. More details are available [here](access.md).
   - If a feature request does not have the "Increasing Access" field sufficiently filled out, you can ask the issue author how the feature increases access.
   - The access statement of a feature can be provided by a different member of the community, including the issue reviewers.
2. The new feature request can be assessed for inclusion based on the following criteria.
   - Does the feature fit into the project scope and [design principles](design_principles.md) of p5.js?
     - For example, a request to add a new drawing primitive shape may be considered, but a request to adopt a browser-based IOT protocol will likely be out of scope.
     - Overall, the scope of p5.js should be relatively narrow in order to avoid excessive bloat from rarely used features.
     - If a feature does not fit into the scope of p5.js, suggest that the issue author implement the feature as as an addon library.
     - If it is unclear whether or not it fits, it can be a good idea to suggest making an addon library as a proof-of-concept. This helps give users a way to use the feature, provides a much more concrete example of its usage and importance, and does not necessarily need to be as complete of a solution as a fully integrated feature. It can be integrated into the core of p5.js later if appropriate.
   - Is the feature likely to cause a breaking change?
     - Will it conflict with existing p5.js functions and variables?
     - Will it conflict with typical sketches already written for p5.js?
     - Features that are likely to cause conflicts such as  the ones above  are  considered breaking changes. Without a [major version release](https://docs.npmjs.com/about-semantic-versioning), we should not make breaking changes to p5.js.
   - Can the proposed new feature be achieved using existing functionalities already in p5.js, relatively simple native JavaScript code, or existing easy-to-use libraries?
     - For example, instead of providing a p5.js function to join an array of strings such as `join(["Hello", "world!"])`, the native JavaScript `["Hello", "world!"].join()` should be preferred instead.
3. If the access requirement and other considerations have been fulfilled, at least two stewards or maintainers must approve the new feature request before work should begin toward a PR. The PR review process for new features is documented below.


### Feature enhancement

Feature enhancement issues should use the "Existing Feature Enhancement" issue template. The process is very similar to new feature requests. The difference between a new feature request and feature enhancement can be blurry sometimes. Feature enhancement mainly deals with existing functions of p5.js while a new feature request could be requesting entirely new functions to be added.

1. Similar to new feature requests, feature enhancement should only be accepted if they increase access to p5.js. Please see point 1 of [section above](steward_guidelines.md#feature-request).
2. Inclusion criteria for feature enhancements are similar to those for feature requests, but particular attention should be paid to potential breaking changes.
   - If modifying existing functions, all previous valid and documented function signatures must behave in the same way.
3. Feature enhancements must be approved by at least one steward or maintainer before work should begin toward a PR. The PR review process for feature enhancement is documented below.


### Discussion

This type of issue has a minimal template ("Discussion") and should be used to gather feedback around a topic in general before coalescing it into something more specific, like a feature request. These sorts of discussion issues can be closed when the conversation finishes and the resulting more specific issues have been created: 

- If an issue is opened as a discussion but should be, for example, a bug report, the correct label should be applied and the "discussion" label removed. Additional info about the bug should also be requested from the author if not already included.
- If an issue is opened as a discussion but isn't relevant to source code contribution or otherwise relevant to the GitHub repositories/contribution process/contribution community, they should be redirected to the forum or Discord and the issue closed.
- If relevant, additional labels should be added to discussion issues to further signal what type of discussion it is at a glance.

---


## Pull Requests

Almost all code contributions to the p5.js repositories happen through pull requests. Stewards and maintainers may have push access to the repositories but are still encouraged to follow the same issue > PR > review process when contributing code. Here are the steps to review a PR:

- Pull request template can be found [here](https://github.com/processing/p5.js/blob/main/.github/PULL_REQUEST_TEMPLATE.md).
- Almost all pull requests must have associated issues opened and discussed first, meaning the relevant [issue workflow](steward_guidelines.md#issues) must have been followed first before a PR should be reviewed by any steward or maintainer.
  - The only instances where this does not apply are very minor typo fixes, which do not require an open issue and can be merged by anyone with merge access to the repo, even if they are not stewards of a particular area.
  - While this exception exists, we will apply it in practice only while contributors are still encouraged to open new issues first. In other words, if in doubt about whether this exception applies, just open an issue anyway.
- If a pull request does not fully solve the referenced issue, you can edit the original post and change "Resolves #OOOO" to "Addresses #OOOO" so that it does not automatically close the original issue when the PR is merged.


### Simple fix

Simple fixes, such as a small typo fix, can be merged directly by anyone with merge access.  Check on the PR "Files Changed" tab to ensure  that the automated CI test passes.

![The "files changed" tab when viewing a pull request on GitHub](images/files-changed.png)

![The "All checks have passed" indicator on a GitHub pull request, highlighted above the merge button](images/all-checks-passed.png)


### Bug fix

1. Bug fixes should be reviewed by the relevant area steward, ideally the same one that approved the referenced issue for fixing.
2. The PR "Files Changed" tab can be used to initially review whether the fix is implemented as described in the issue discussion.
3. The PR should be tested locally whenever possible and relevant. The GitHub CLI can help streamline some of the process. (See more below in [Tips & Tricks](steward_guidelines.md#tips-tricks)).
   - [ ] The fix should address the original issue sufficiently.
   - [ ] The fix should not change any existing behaviors unless agreed upon in the original issue.
   - [ ] The fix should not have a significant performance impact on p5.js.
   - [ ] The fix should not have any impact on p5.js' accessibility.
   - [ ] The fix should use the modern standard of JavaScript coding.
   - [ ] The fix should pass all automated tests and include new tests if relevant.
4. If any additional changes are required, line comments should be added to the relevant lines as described [here](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request).
   - A suggestion block can also be used to suggest specific changes:\
     ![The Suggest Change button while writing a comment on code in a GitHub pull request](images/suggest-change.png)\
     ![A suggested change appearing within code fences with the "suggestion" tag](images/suggested-value-change.png)\
     ![A suggested change previewed as a diff](images/suggestion-preview.png)
   - If multiple changes are required, don’t add single-line comments many times. Instead, follow the procedure documented [here](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/reviewing-proposed-changes-in-a-pull-request) to make multiple-line comments and a single request for changes.
   - If line comments are just for clarification or discussion, choose “Comment” instead of "Request changes":\
     ![The "comment" option circled within the GitHub Finish Review menu](images/comment-review.png)
5. Once the PR has been reviewed and no additional changes are required, a steward can mark the PR as "Approved" by choosing the "Approve" option in the previous step, with or without additional comments. The steward can then either request additional review by another steward or maintainer if desired, merge the PR if they have merge access, or request a merge from a maintainer.

6. @[all-contributors](https://allcontributors.org/docs/en/emoji-key) bot should be called to add any new contributors to the list of contributors in the README.md file. Each type of contribution can be indicated in place of `[contribution` `type]` below, the full list of available types of contributions can be found in the link above.

`@all-contributors` `please` `add` `@[GitHub` `handle]` `for` `[contribution` `type]`


### New feature/feature enhancement

The process for new feature or feature enhancement PR is similar to bug fixes with just one notable difference:

- A new feature/feature enhancement PR must be reviewed and approved by at least two stewards or maintainers before it can be merged.


### Dependabot

Dependabot PRs are usually only visible to repo admins so if this does not apply to you, please skip this section.

- Dependabot PRs can be merged directly if the version update is a [semver](https://semver.org/) patch version and the automated CI test has passed.
- Dependabot PRs with semver minor version changes can usually be merged directly as long as automated CI test passes. A quick check on the changelog of the updated dependency is recommended.
- Dependabot PRs with semver major version changes may likely affect either the build process or p5.js functionalities. The reviewer, in this case, is encouraged to review the changelog from the current version to the target version if possible and test the PR locally to ensure all processes are functioning and make any required changes due to potential breaking changes in the dependencies.
  - Many dependencies bump major version numbers only because they drop official support for very old versions of Node.js. In many cases, major version changes don't necessarily mean breaking changes resulting from dependency API changes.

---


## Build process

This section will not cover the general build setup nor commands but rather details about what's happening behind the scenes. Please see the [contributor’s guidelines](contributor_guidelines.md#working-on-p5js-codebase) for more detailed build info.

The Gruntfile.js file contains the main build definitions for p5.js. Among the different tools used to build the library and documentation includes but not limited to Grunt, Browserify, YUIDoc, ESLint, Babel, Uglify, and Mocha. It may be helpful for us to start with the `default` task and work backward from there. It may be helpful at this point to open up the Gruntfile.js document while going through the explainer below.


### Main build task

```
grunt.registerTask('default', ['lint', 'test']);
```

When we run `grunt` or the npm script `npm test`, we run the default task consisting of `lint` then `test`.


#### `lint` Task

```
grunt.registerTask('lint', ['lint:source', 'lint:samples']);
```

The `lint` task consists of two sub tasks: `lint:source` and `lint:samples`. `lint:source` is further subdivided into three more sub tasks `eslint:build`, `eslint:source`, and `eslint:test`, which uses ESLint to check the build scripts, the source code, and the test scripts.

The `lint:samples` task will first run the `yui` task which itself consists of `yuidoc:prod`, `clean:reference`, and `minjson`, which extract the documentation from the source code into a JSON document, remove unused files from the previous step, and minify the generated JSON file into `data.min.json` respectively.

Next in `lint:samples` is `eslint-samples:source`, which is a custom written task whose definition is in [./tasks/build/eslint-samples.js](tasks/build/eslint-samples.js); it will run ESLint to check the documentation example code to make sure they follow the same coding convention as the rest of p5.js (`yui` is run first here because we need the JSON file to be built first before we can lint the examples).


#### `test` Task

```js
grunt.registerTask('test', [
  'build',
  'connect:server',
  'mochaChrome',
  'mochaTest',
  'nyc:report'
]);
```

First let's look at the `build` task under `test`.

```js
grunt.registerTask('build', [
  'browserify',
  'browserify:min',
  'uglify',
  'browserify:test'
]);
```

Tasks that start with `browserify` are defined in [./tasks/build/browserify.js](tasks/build/browserify.js). They all  similar steps with minor differences. These are the main steps to build the full p5.js library from its many source code files into one:

- `browserify` builds p5.js while `browserify:min` builds an intermediate file to be minified in the next step. The difference between `browserify` and `browserify:min` is that `browserify:min` does not contain data needed for FES to function.
- `uglify` takes the output file of `browserify:min` and minify it into the final p5.min.js (configuration of this step is in the main Gruntfile.js).
- `browserify:test` is building a version identical to the full p5.js except for added code that is used for test code coverage reporting (using [Istanbul](https://istanbul.js.org/)).

First, use of the `fs.readFileSync()` node.js specific code is replaced with the file's actual content using `brfs-babel`. This is used mainly by WebGL code to inline shader code from source code written as separate files.

Next, the source code, including all dependencies from node\_modules, is transpiled using Babel to match the [Browserslist](https://browsersl.ist/) requirement defined in package.json as well as to make the ES6 import statements into CommonJS `require()` that browserify understands. This also enables us to use newer syntax available in ES6 and beyond without worrying about browser compatibility.

After bundling but before the bundled code is written to file, the code is passed through `pretty-fast`, if it is not meant to be minified, it should be cleaned up so the final formatting is a bit more consistent (we anticipate the p5.js source code can be read and inspected if desired).

A few small detailed steps are left out here; you can check out the browserify build definition file linked above to have a closer look at everything.

```
connect:server
```

이 단계에서는 테스트 파일과 빌드된 소스 코드 파일을 호스팅하는 로컬 서버를 가동하여 Chrome에서 자동화된 테스트를 실행할 수 있도록 합니다.

```
mochaChrome
```

이 단계는 [./tasks/test/mocha-chrome.js](tasks/test/mocha-chrome.js)에 정의되어 있습니다. Puppeteer를 사용해 원격 제어가 가능한 Chrome의 헤드리스 버전을 가동하고, `./test` 폴더에 있는 HTML 파일과 관련된 테스트를 실행합니다. 여기에는 라이브러리의 축소되지 않은 버전과 축소된 버전을 단위 테스트(unit test) 모음에 대해 테스트하는 것은 물론, 모든 참조 예제를 테스트하는 것도 포함되어 있습니다. 

```
mochaTest
```

이 단계는 Chrome 대신 node.js에서 실행되고 라이브러리의 기능 중 일부만 테스트한다는 점에서 `mochaChrome`과 차이가 있습니다. 대부분의 p5.js 기능은 브라우저 환경이 필요하므로 이 테스트 세트는 새로운 테스트에 브라우저 환경이 필요하지 않을 때만 확장해야 합니다.

```
nyc:report
```

마지막으로, 모든 빌드와 테스트가 완료되면 이 단계에서는 `mochaChrome`이 전체 라이브러리 버전을 테스트하는 동안 테스트 커버리지 보고서를 수집하고, 테스트 범위 데이터를 콘솔에 출력합니다. p5.js의 테스트 커버리지는 주로 추가적인 데이터 포인트를 모니터링하고 확보하는 것으로, 테스트 커버리지 100%를 목표로 하지는 않습니다.

그리고 그것은 Gruntfile.js 구성의 기본 작업을 다루고 있습니다!


### 기타 작업

모든 단계는 `npx grunt [step]`으로 직접 실행할 수 있습니다. 위에서 다루지는 않았지만 특정 상황에서 유용할 수 있는 몇 가지 작업도 있습니다.

```
grunt yui:dev
```

이 작업은 위에 설명된 문서 및 라이브러리 빌드를 실행한 다음, [http://localhost:9001/docs/reference/](http://localhost:9001/docs/reference/)의 웹사이트에서 찾을 수 있는 참조 페이지와 유사한 기능을 가진 버전을 제공하는 웹 서버를 가동합니다. 그런 다음 소스 코드의 변경점을 모니터링하고 문서와 라이브러리를 다시 빌드합니다.

`grunt` `yui:dev`는 인라인 문서의 참조 작업을 할 때 유용한데, 빌드된 파일을 p5.js 저장소(repository)에서 로컬 p5.js-웹사이트 저장소로 이동할 필요도, 변경사항이 생길 때마다 웹사이트를 다시 빌드할 필요도 없기 때문입니다. 그저 브라우저에서 약간 단순화된 참조 버전으로 변경사항을 미리 보면 됩니다. 이렇게 하면 변경사항이 웹사이트에 더욱 올바르게 표시될 것이라는 확신을 가질 수도 있습니다. 이는 인라인 문서를 수정하는 경우에만 해당된다는 것을 알아두세요. 스타일 및 레이아웃 작업을 포함한 참조 페이지 자체에 대한 변경사항은 웹사이트 저장소에서 생기고 테스트해야 합니다.


```
grunt watch
grunt watch:main
grunt watch:quick
```

Watch 작업은 여러 파일의 변경사항을 감시하고, 관련 작업을 실행하여 변경된 파일에 따라 참조나 라이브러리를 빌드합니다. 이러한 작업은 범위의 차이를 제외하면 모두 동일한 작업을 수행합니다. 

`watch` 작업은 소스 코드의 변경사항을 감지할 때 전체 기본 작업을 실행하는 것과 비슷한 모든 빌드와 테스트를 실행합니다. 

`watch:main` 작업은 라이브러리 빌드와 테스트를 실행하지만, 소스 코드의 변경사항을 감지해도 참조를 다시 빌드하지는 않습니다.

`watch:quick` 작업은 소스 코드의 변경사항이 감지된 경우에만 라이브러리 빌드를 실행합니다.

작업 중인 내용에 따라 가장 적은 감시 작업이 일어나는 것을 선택한다면 변경사항을 만들고 싶을 때마다 수동으로 다시 빌드를 하지 않아도 됩니다.

---


## 배포 과정

[release\_process.md](release_process.md)를 확인하세요.

---


## 팁과 요령

때때로 검토가 필요한 이슈와 PR의 수가 너무 많아질 수도 있습니다. 저희가 이를 더 쉽게 만드는 과정을 마련하려는 동안 이슈와 PR을 검토하는 데 도움이 될 만한 몇 가지 팁과 요령을 알려드립니다.


### 회신(Reply) 양식

사용할 수 있는 편리한 깃허브(GitHub) 기능은 이슈 또는 풀 요청(pull request)에 대한 회신을 작성할 떄 사용할 수 있는 [저장된 회신](https://docs.github.com/en/get-started/writing-on-github/working-with-saved-replies/about-saved-replies) 기능입니다. 위에 설명된 작업 흐름(workflow) 중 일부는 동일하거나 매우 유사한 답변(포럼으로 질문을 리디렉션하거나, 수정을 위한 이슈 수락 등)으로 이슈 또는 PR에 응답해야 할 수도 있는데, **저장된 회신**을 사용하면 이 작업의 효율이 조금 더 올라갈 수 있습니다.

다음은 p5.js 메인테이너가 사용하는 **저장된 회신**의 일부입니다. 이를 사용하거나 직접 만들어 보세요!


##### 종결: 재현할 수 없음

> 이것을 재현할 수는 없지만, 이 이슈를 보여줄 수 있는 샘플 코드를 제공할 수 있다면 다시 열어주세요. 감사합니다!


##### 종결: 스니펫 필요

> 조직적인 목적으로 이 이슈를 종결합니다. 이 이슈를 설명하는 코드 스니펫을 제공할 수 있다면 다시 열어주세요. 감사합니다!


##### 종결: 포럼 사용

> 이 깃허브 이슈는 p5.js 라이브러리 자체의 버그나 이슈를 올리기에 좋은 곳입니다. 여러분의 코드나 테스트, 또는 튜토리얼을 따라하는 것에 대한 질문을 하고 싶다면 [포럼](https://discourse.processing.org/)만한 곳이 없을 거에요. 감사합니다!


##### 종결: GSOC

> 감사합니다! GSOC 제안을 논의하고 싶다면 우리의 [포럼](https://discourse.processing.org/c/summer-of-code)만한 곳이 없답니다.


##### 종결: 접근성

> 저는 이 기능에 큰 관심이 없고, 어떻게 [접근성을 확장](access.md)하는지에 대한 명확한 설명이 없으므로 일단 이 이슈를 종결하겠습니다. 이슈 요청에 접근성 설명을 추가할 수 있게 되면 언제든지 다시 열어주세요.

> 이 이슈로 인해 어떻게 [접근성이 확장](access.md)되는지에 대한 추가 설명이 없으므로 일단 이 이슈를 종결하겠습니다. 기능 요청에 더 자세한 접근성 설명을 추가할 수 있게 되면 언제든지 다시 열어주세요. 감사합니다!


##### 종결: 애드온

> 저는 이 기능이 p5.js API의 범위를 벗어나는 것이라고 생각하지만 (최소한의 크기를 유지하고 싶어요), 애드온 라이브러리를 만드는 좋은 시작점이 될 것 같습니다. 애드온을 생성하는 방법을 알고 싶다면 이 문서를 확인해 보세요. [https://github.com/processing/p5.js/blob/main/contributor\_docs/creating\_libraries.md](creating_libraries.md)


##### PR 종결: 이슈가 먼저 필요함

> 감사합니다. 참고로, 풀 요청(pull request)을 게시하고 이슈에 태그를 지정하기 전에 먼저 이슈를 게시해야 합니다. 이는 개발을 추적하고 토론을 명확하게 유지하는 데 필요해요. 감사합니다!


##### 이슈 해결 승인

> 계속 해결해도 됩니다. 감사합니다!


##### PR 병합

> 괜찮아 보이는데요? 감사합니다!


### 깃허브 CLI

테스트할 PR의 코드 버전을 로컬로 가져오는 데 필요한 복잡한 git 명령어를 사용하면 복잡한 PR을 검토하는 게 어려울 수 있습니다. 다행히도 [깃허브 CLI](https://cli.github.com/)가 이 과정에서 큰 도움을 줄 수 있겠군요.

CLI를 설치하고 로그인하고 `gh pr checkout [pull_request_id]` 명령어를 실행하면 로컬에서 PR 검토가 가능하며, 원격 포크 가져오기, 브랜치 생성, 브랜치 체크아웃 과정이 모두 자동으로 수행됩니다. main 브랜치로 돌아가는 것은 `git checkout main`으로 브랜치를 전환하는 것과 같습니다. 심지어 웹사이트를 방문하지 않고도 CLI에서 PR에 댓글을 남길 수도 있습니다!

깃허브 CLI에는 유용할 수도, 그렇지 않을 수도 있는 수많은 명령어가 있지만, 여전히 사용하기에 좋은 도구입니다.


### 알림 관리

새로운 이슈나 PR에 대해 **이슈** 나 **풀 요청** 탭을 수동으로 감시하지 말고, 저장소 이름 맞은편 저장소 페이지 상단에 눈 아이콘이 있는 **보기(Watch)** 버튼을 클릭하여 저장소를 감시할 수 있습니다.

![왼쪽에서 오른쪽으로 중앙에 있는 Sponsor, Watch, Fork, Starring 등의 버튼을 포함한 깃허브(GitHub) 저장소 페이지의 오른쪽 상단을 잘라낸 스크린샷](images/github-repo-metrics.png)

저장소 보기를 활성화하면, 새 이슈, 풀 요청, 사용자 핸들에 대한 언급 및 저장소에서 구독한 다른 활동과 같은 이벤트가 [알림 페이지](https://github.com/notifications)에 알림으로 전송되며, 이메일의 받은 편지함과 비슷하게 _읽음_, _삭제됨_ 으로 표시될 수 있습니다.

경우에 따라 보기가 활성화된 저장소에 대한 이메일을 GitHub로부터 수신할 수도 있으며, [알림 설정 페이지](https://github.com/settings/notifications)에서 (아예 구독 취소하는 것을 포함한) 사용자 설정을 할 수 있습니다.

작업 방식에 맞게 이를 설정하고 싶다면, 검토할 관련 이슈 및 PR을 수동으로 찾아야 하는 귀찮음과, 깃허브의 끝없는 알림 속에서의 압도 사이에서 어떤 것을 선택할 것인지에 대한 기로에 서 있게 됩니다. 여기에는 균형 잡힌 선택이 필요한데, 만약 처음이라면 스튜어드는 **이슈**와 **풀 요청**에 대해 이 저장소에 **보기**를 활성화하고, "참여, @멘션 및 사용자 정의"에 대한 이메일만 수신하도록 설정하는 것을 추천합니다. 
